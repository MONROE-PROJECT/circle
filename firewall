#!/bin/bash

# INPUT: Inbound traffic destined for this host
# OUTPUT: Outbound traffic originating from this host
# FORWARD: Traffic passing through this host (both other origin and destination)

set -o errexit
set -o pipefail
set -o nounset

VERSION="1.0.0"

CONFD="/etc/firewall.d"
CEXCL="chains.exclude"

ipt4="/sbin/iptables"
ipt6="null"
ebt="null"

in_policy="DROP"
out_policy="DROP"
forward_policy="DROP"

use_ebt=false
use_ipt6=false

verbose=false
silent=false
log_illegal=false
log_level=4


null(){ :; }

log()
{
    if [ ${1} -le "${log_level}" ]
    then
        logger -t ipt-firewall "${2}"
    fi
}

debug(){ log 6 "DEBUG: ${1}"; }
note(){ log 5 "NOTICE: ${1}"; }
info(){ log 4 "INFO: ${1}"; }
warn(){ log 3 "WARNING: ${1}"; }
err(){ log 2 "ERROR: ${1}"; }

display_help()
{
    echo "Usage: $(basename ${BASH_SOURCE[0]}) [options] <command>"
    echo ""
    echo "    -6        Enable IP6TABLES"
    echo "    -e        Enable EBTABLES"
    echo "    -i        Log illegal lines in source files"
    echo "    -l INT    Log level (2-6), default 4"
    echo "    -V        Be verbose"
    echo "    -s        Be silent"
    echo "    -I STR    Set INPUT chain policy"
    echo "    -F STR    Set FORWARD chain policy"
    echo "    -O STR    Set OUTPUT chain policy"
    echo "    -h        Print this help message and exit"
    echo "    -v        Show version and exit"
    echo ""
    echo "Commands:"
    echo "    start     clear and load firewall rules"
    echo "    stop      clear rules"
    echo "    restart   alias for 'start'"
}

display_version()
{
    echo "$(basename ${BASH_SOURCE[0]}) v${VERSION}"
}

sanity()
{
    # Must be root
    if [ "${EUID}" -ne 0 ]
    then
        [ ${silent} = false ] && echo "firewall requires root privileges, exiting" >&2
        err "firewall requires root privileges, aborting"
        exit 1
    fi

    # Make sure conf.d directory exists
    if [ ! -d "${CONFD}" ]
    then
        [ ${silent} = false ] && echo "configuration directory '${CONFD}' does not exist" >&2
        err "configuration directory '${CONFD}' does not exist"
        exit 1
    fi

    # Make sure IPTABLES and EBTABLES are present
    if [ ! -f "${ipt4}" ]
    then
        [ ${silent} = false ] && echo "${IPT} missing" >&2
        err "${IPT} missing"
        exit 1
    elif [ ${use_ipt6} = true ] && [ ! -f "${ipt6}" ]
    then
        [ ${silent} = false ] && echo "${ipt6} missing" >&2
        err "${ipt6} missing"
        exit 1
    elif [ ${use_ebt} = true ] && [ ! -f "${ebt}" ]
    then
        [ ${silent} = false ] && echo "${ebt} missing" >&2
        err "${ebt} missing"
        exit 1
    fi
}

contains()
{
    local needle=${1}
    declare -a haystack=("${!2}")

    for item in ${haystack[@]}
    do
        if [ "${needle}" = "${item}" ]
        then
            return 0
        fi
    done
    return 1
}

valid_policy()
{
    local policy=${1}
    local valid=("ACCEPT" "DROP" "REJECT" "QUEUE")
    return $(contains ${policy} valid[@])
}

clear_chains()
{
    local chains=()
    if [ ${1} = "ipt4" ]
    then
        chains=$(${ipt4} -L|grep Chain|awk '{print $2}')
        local tool=${ipt4}
    elif [ ${1} = "ipt6" ]
    then
        chains=$(${ipt6} -L|grep Chain|awk '{print $2}')
        local tool=${ipt6}
    else
        [ ${silent} = false ] && echo "clear_chains() cannot handle '${1}'" >&2
        err "clear_chains() cannot handle '${1}'"
        exit 1
    fi

    local exclude=()
    if [ -f "${CONFD}/${1}-${CEXCL}" ]
    then
        readarray -t exclude < "${CONFD}/${1}-${CEXCL}"
    fi

    # Can't delete built-in chains, but always flush
    standard=("INPUT" "OUTPUT" "FORWARD")
    exclude+=("INPUT")
    exclude+=("OUTPUT")
    exclude+=("FORWARD")
    ${tool} -F INPUT
    ${tool} -F OUTPUT
    ${tool} -F FORWARD

    ${tool} -t nat -F PREROUTING
    ${tool} -t nat -F INPUT
    ${tool} -t nat -F OUTPUT
    ${tool} -t nat -F POSTROUTING
    ${tool} -t mangle -F PREROUTING
    ${tool} -t mangle -F INPUT
    ${tool} -t mangle -F OUTPUT
    ${tool} -t mangle -F FORWARD
    ${tool} -t mangle -F POSTROUTING

    for chain in ${chains[@]}
    do
        if contains ${chain} exclude[@]
        then
            if ! contains ${chain} standard[@]
            then
                [ ${verbose} = true -a ${silent} = false ] && echo "excluding chain '${chain}'"
                info "excluding chain '${chain}'"
            fi
            continue
        fi
        [ ${verbose} = true -a ${silent} = false ] && echo "deleting chain '${chain}'"
        debug "flushing ${chain}"
        ${tool} -F ${chain}
        debug "deleting ${chain}"
        ${tool} -X ${chain}
    done
}

# Remove all rules and chains
remove_all()
{
    [ ${verbose} = true -a ${silent} = false ] && echo "removing previous firewall rules.."
    info "removing firewall rules"
    # IPv4
    clear_chains "ipt4"

    # IPv6
    if [ ${use_ipt6} = true ]
    then
        clear_chains "ipt6"
    fi
}

# Load rules
load()
{
    if [ ! $# -eq 1 ]
    then
        [ ${silent} = false ] && echo "attempted to load rule, but no file name was given" >&2
        error "attempted to load rules, but no file name was given"
        exit 1
    fi

    # Check for illegal characters
    if grep -qEe '.*;.*' -Ee '\$\(.*\)' -Ee '([&]|[|])' -Ee '[\`]' ${1}
    then
        [ ${verbose} = true -a ${silent} = false ] && echo "illegal characters detected in file."
        warn "illegal characters detected in file '${1}'"
    fi

    if [ ${log_illegal} = true ]
    then
        # Log illegal lines
        while read -r line
        do
            warn "illegal characters detected in line '${line}'"
        done < <(grep -Ee '.*;.*' -Ee '\$\(.*\)' -Ee '([&]|[|])' -Ee '[\`]' ${1})
    fi

    # Load lines that seem to be legal
    while read -r line
    do
        debug "loading line '${line}'"
        eval ${line}
    done < <(grep -e "^\${" ${1}|grep -vEe ".*;.*" -vEe "\$\(.*\)" -vEe "([&]|[|])" -vEe "[\`]")
}

start()
{
    sanity

    # Avoid lock out in case of error
    ${ipt4} -P INPUT ACCEPT
    ${ipt4} -P OUTPUT ACCEPT
    ${ipt4} -P FORWARD ACCEPT
    # IPv6
    if [ ${use_ipt6} = true ]
    then
        ${ipt6} -P INPUT ACCEPT
        ${ipt6} -P OUTPUT ACCEPT
        ${ipt6} -P FORWARD ACCEPT
    fi

    # Remove any previous rules or chains
    remove_all

    [ ${verbose} = true -a ${silent} = false ] && echo "setting up ipt-firewall.."
    info "setting up firewall"

    # Load all rules
    for file in ${CONFD}/*.rules
    do
        if [ -f "${file}" ]
        then
            [ ${verbose} = true -a ${silent} = false ] && echo "ipt-firewall loading file '${file}'"
            note "loading rules file '${file}'"
            load ${file}
        fi
    done

    # Drop everything not previously matched in default chains
    ${ipt4} -A INPUT -j ${in_policy}
    ${ipt4} -A OUTPUT -j ${out_policy}
    ${ipt4} -A FORWARD -j ${forward_policy}
    # IPv6
    if [ ${use_ipt6} = true ]
    then
        ${ipt6} -A INPUT -j ${in_policy}
        ${ipt6} -A OUTPUT -j ${out_policy}
        ${ipt6} -A FORWARD -j ${forward_policy}
    fi

    [ ${verbose} = true -a ${silent} = false ] && echo "ipt-firewall finished loading"
    note "firewall rules finished loading"
}

# getopt index variable
OPTIND=1
while getopts ":6eil:VsI:F:O:hv" opt; do
    case ${opt} in
        6)
            use_ipt6=true
            ipt6="/sbin/ip6tables"
            ;;
        e)
            use_ebt=true
            ebt="/sbin/ebtables"
            ;;
        i)
            log_illegal=true
            ;;
        l)
            local valid_levels=(2 3 4 5 6)
            if ! contains "${OPTARG}" valid_levels[@]
            then
               echo "Invalid log level '${OPTARG}', available 2-6" >&2
               error "Invalid log level '${OPTARG}', available 2-6"
               exit 1
            fi
            log_level=${OPTARG}

            ;;
        V)
            verbose=true
            ;;
        s)
            silent=true
            ;;
        I)
            if ! valid_policy "${OPTARG}"
            then
                echo "Invalid policy '${OPTARG}'" >&2
                error "Invalid policy '${OPTARG}'"
                exit 1
            fi
            in_policy=${OPTARG}
            ;;
        F)
            if ! valid_policy "${OPTARG}"
            then
                echo "Invalid policy '${OPTARG}'" >&2
                error "Invalid policy '${OPTARG}'"
                exit 1
            fi
            forward_policy=${OPTARG}
            ;;
        O)
            if ! valid_policy "${OPTARG}"
            then
                echo "Invalid policy '${OPTARG}'" >&2
                error "Invalid policy '${OPTARG}'"
                exit 1
            fi
            out_policy=${OPTARG}
            ;;
        h)
            display_help
            exit 0
            ;;
        v)
            display_version
            exit 0
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            error "Invalid option: -${OPTARG}"
            display_help
            exit 1
            ;;
        :)
            echo "Option -${OPTARG} requires an argument" >&2
            error "Option -${OPTARG} requires an argument"
            display_help
            exit 1
            ;;
    esac
done

# Remove all option arguments
shift $(($OPTIND - 1))

if [ ${#} = 0 ]
then
    error "No command specified"
    display_help
    exit 1
fi

case "${1}" in
    start)
        start
        ;;
    stop)
        remove_all
        ;;
    restart)
        start
        ;;
    *)
        error "Unknown command '${1}'"
        display_help
        exit 1
        ;;
esac

