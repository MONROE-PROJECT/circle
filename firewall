#!/bin/bash

# INPUT: Inbound traffic destined for this host
# OUTPUT: Outbound traffic originating from this host
# FORWARD: Traffic passing through this host (both other origin and destination)

set -o errexit
set -o pipefail
set -o nounset

IPT4="/sbin/iptables"
CONFD="/etc/firewall.d"
CEXCL="chains.exclude"

use_ebt=false
use_ipt6=false

verbose=true
log_illegal=false
log_level=4

log()
{
    if [ ${1} -le "${log_level}" ]
    then
        logger -t ipt-firewall "${2}"
    fi
}

debug(){ log 6 "DEBUG: ${1}"; }
note(){ log 5 "NOTICE: ${1}"; }
info(){ log 4 "INFO: ${1}"; }
warn(){ log 3 "WARNING: ${1}"; }
err(){ log 2 "ERROR: ${1}"; }

help()
{
    echo "Usage: $(basename ${BASH_SOURCE[0]}) [options] <command>"
    echo ""
    echo "    -6        enable IP6TABLES"
    echo "    -e        enable EBTABLES"
    echo "    -i        log illegal lines in source files"
    echo "    -l INT    log level (2-6), default 4"
    echo "    -s        do not print firewall output"
    echo "    -h        print this help message"
    echo ""
    echo "Commands:"
    echo "    start     clear and load firewall rules"
    echo "    stop      clear rules"
    echo "    restart   alias for 'start'"
}

sanity()
{
    # Must be root
    if [ "${EUID}" -ne 0 ]
    then
        echo "firewall requires root privileges, exiting"
        err "firewall requires root privileges, aborting"
        exit 1
    fi

    # Make sure conf.d directory exists
    if [ ! -d "${CONFD}" ]
    then
        echo "configuration directory '${CONFD}' does not exist"
        err "configuration directory '${CONFD}' does not exist"
        exit 1
    fi

    # Make sure IPTABLES and EBTABLES are present
    if [ ! -f "${IPT4}" ]
    then
        [ ${verbose} = true ] && echo "${IPT} missing"
        err "${IPT} missing"
        exit 1
    elif [ ${use_ipt6} = true ] && [ ! -f "${IPT6}" ]
    then
        [ ${verbose} = true ] && echo "${IPT6} missing"
        err "${IPT6} missing"
        exit 1
    elif [ ${use_ebt} = true ] && [ ! -f "${EBT}" ]
    then
        [ ${verbose} = true ] && echo "${EBT} missing"
        err "${EBT} missing"
        exit 1
    fi
}

contains()
{
    local needle=$1
    declare -a haystack=("${!2}")

    for item in ${haystack[@]}
    do
        if [ "$needle" == "$item" ]
        then
            return 0
        fi
    done
    return 1
}

clear_chains()
{
    local chains=()
    if [ $1 = "ipt4" ]
    then
        chains=$(${IPT4} -L|grep Chain|awk '{print $2}')
        local tool=${IPT4}
    elif [ $1 = "ipt6" ]
    then
        chains=$(${IPT6} -L|grep Chain|awk '{print $2}')
        local tool=${IPT6}
    else
        err "clear_chains() cannot handle '$1'"
        exit 1
    fi

    local exclude=()
    if [ -f "${CONFD}/${1}-${CEXCL}" ]
    then
        readarray -t exclude < "${CONFD}/${1}-${CEXCL}"
    fi

    # Can't delete built-in chains, but always flush
    standard=("INPUT" "OUTPUT" "FORWARD")
    exclude+=("INPUT")
    exclude+=("OUTPUT")
    exclude+=("FORWARD")
    ${tool} -F INPUT
    ${tool} -F OUTPUT
    ${tool} -F FORWARD

    ${tool} -t nat -F PREROUTING
    ${tool} -t nat -F INPUT
    ${tool} -t nat -F OUTPUT
    ${tool} -t nat -F POSTROUTING
    ${tool} -t mangle -F PREROUTING
    ${tool} -t mangle -F INPUT
    ${tool} -t mangle -F OUTPUT
    ${tool} -t mangle -F FORWARD
    ${tool} -t mangle -F POSTROUTING

    for chain in ${chains[@]}
    do
        if contains ${chain} exclude[@]
        then
            if ! contains ${chain} standard[@]
            then
                [ ${verbose} = true ] && echo "excluding chain '${chain}'"
                info "excluding chain '${chain}'"
            fi
            continue
        fi
        [ ${verbose} = true ] && echo "deleting chain '${chain}'"
        debug "flushing ${chain}"
        ${tool} -F ${chain}
        debug "deleting ${chain}"
        ${tool} -X ${chain}
    done
}

# Remove all rules and chains
remove_all()
{
    [ ${verbose} = true ] && echo "removing previous firewall rules.."
    info "removing firewall rules"
    # IPv4
    clear_chains "ipt4"
    #${IPT4} -t nat -F
    #${IPT4} -t nat -X
    #${IPT4} -t mangle -F
    #${IPT4} -t mangle -X

    # IPv6
    if [ ${use_ipt6} = true ]
    then
        clear_chains "ipt6"
        #${IPT6} -t nat -F
        #${IPT6} -t nat -X
        #${IPT6} -t mangle -F
        #${IPT6} -t mangle -X
    fi
}

# Load rules
load()
{
    if [ ! $# -eq 1 ]
    then
        [ ${verbose} = true ] && echo "attempted to load rule, but no file name was given"
        error "attempted to load rules, but no file name was given"
        exit 1
    fi

    # Check for illegal characters
    if grep -qEe '.*;.*' -Ee '\$\(.*\)' -Ee '([&]|[|])' -Ee '[\`]' ${1}
    then
        [ ${verbose} = true ] && echo "illegal characters detected in file."
        warn "illegal characters detected in file '${1}'"
    fi

    if [ ${log_illegal} = true ]
    then
        # Log illegal lines
        while read -r line
        do
            warn "illegal characters detected in line '${line}'"
        done < <(grep -Ee '.*;.*' -Ee '\$\(.*\)' -Ee '([&]|[|])' -Ee '[\`]' ${1})
    fi

    # Load lines that seem to be legal
    while read -r line
    do
        debug "loading line '${line}'"
        eval ${line}
    done < <(grep -e "^\${" ${1}|grep -vEe ".*;.*" -vEe "\$\(.*\)" -vEe "([&]|[|])" -vEe "[\`]")
}

start()
{
    sanity

    # Avoid lock out in case of error
    ${IPT4} -P INPUT ACCEPT
    ${IPT4} -P OUTPUT ACCEPT
    ${IPT4} -P FORWARD ACCEPT
    # IPv6
    if [ ${use_ipt6} = true ]
    then
        ${IPT6} -P INPUT ACCEPT
        ${IPT6} -P OUTPUT ACCEPT
        ${IPT6} -P FORWARD ACCEPT
    fi

    # Remove any previous rules or chains
    remove_all

    [ ${verbose} = true ] && echo "setting up ipt-firewall.."
    info "setting up firewall"

    # Load all rules
    for file in ${CONFD}/*.rules
    do
        if [ -f "${file}" ]
        then
            [ ${verbose} = true ] && echo "ipt-firewall loading file '${file}'"
            note "loading rules file '${file}'"
            load ${file}
        fi
    done

    # Drop everything not previously matched in default chains
    ${IPT4} -A INPUT -j DROP
    ${IPT4} -A OUTPUT -j DROP
    ${IPT4} -A FORWARD -j DROP
    # IPv6
    if [ ${use_ipt6} = true ]
    then
        ${IPT6} -A INPUT -j DROP
        ${IPT6} -A OUTPUT -j DROP
        ${IPT6} -A FORWARD -j DROP
    fi

    [ ${verbose} = true ] && echo "ipt-firewall finished loading"
    note "firewall rules finished loading"
}

# getopt index variable
OPTIND=1
while getopts ":6eil:sh" opt; do
    case $opt in
        6)
            use_ipt6=true
            IPT6="/sbin/ip6tables"
            ;;
        e)
            use_ebt=true
            EBT="/sbin/ebtables"
            ;;
        i)
            log_illegal=true
            ;;
        l)
            log_level=${OPTARG}
            ;;
        s)
            verbose=false
            ;;
        h)
            help
            exit 0
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            exit 1
            ;;
        :)
            echo "Option -${OPTARG} requires an argument." >&2
            exit 1
            ;;
    esac
done

# Remove all option arguments
shift $(($OPTIND - 1))

if [ $# = 0 ]
then
    echo "no command specified"
    help
    exit 1
fi

case "${1}" in
    start)
        start
        ;;
    stop)
        # Remove any rules or chains
        remove_all
        ;;
    restart)
        start
        ;;
    *)
        echo "Usage: firewall {start|stop|restart}"
        ;;
esac

